//Variable Declarations
int n = 80;
int[][] cells;
int[][] newCells;
float cellSize;
float padding = 30;
int blinksPerSecond = 15;
int[] lastTornado;
float rand;
int genCount;
String danger;
String cellBehaviour;
float[][] xDist;
float[][] yDist;
float leftValue;
float rightValue;
float upValue;
float downValue;
float frq;
int lightningX;
int lightningY;
int lastStrikeX;
int lastStrikeY;
int r;

//0 = Empty
//1 = Alive
//2 = Lightning
//3 = Tornado

void setup() {
  //Define Variables
  size(900,900);
  frameRate(blinksPerSecond);
  cellSize = (width - (2 * padding)) / n;
  cells = new int[n][n];
  newCells = new int[n][n];
  xDist = new float[n][n];
  yDist = new float[n][n];
  frq = 15;
  danger = "lightning"; //Danger can be "lightning" or "tornado"
  cellBehaviour = "unaware"; //Cells can be "unaware" or "aware"
  genCount = 0;
  r = 7;
  
  //Call starting function
  setStartPosition();
}

void setStartPosition() {
  
  //For every cell
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      //Creates randon number between 0 and 9
      rand = int(random(20));
      
      //Creates a one in twenty chance that the cell begins alive
      if (rand == 0)
        cells[i][j] = 1;
        
      else 
        cells[i][j] = 0;
    }
  }
}

void draw() {
  background(200,180,100);
  float y = padding;
  
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      float x = padding + (j * cellSize);
      
      if (cells[i][j] == 0)
        fill(0,100,0);
      
      else if (cells[i][j] == 1)
        fill(230,100,0);
        
      else if (cells[i][j] == 2)
        fill(255,255,80);
        
      rect(x, y, cellSize, cellSize);
    }
    y += cellSize;
  }
  
  createNextGeneration();
}

void createNextGeneration() {
  movePopulation();
  
  //If the fanger is tornado
  if (danger == "tornado")
    moveTornado();
    
  //If the danger is lightning 
  else if (danger == "lightning")
    checkLightning();
    
  genCount++;
}

void movePopulation() {
  //Call before for loop
  if (genCount > 10 && cellBehaviour == "aware")
    findDist();
  
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      
      if (cells[i][j] == 1) {
        //From 0-4, the five values represent moving up, down, left, right, and staying still
        rand = random(5);
        
        //Using the ratios of the length/height to the x/y dist from danger to add
        //a factor of urgency to each direction to simulate running away
        
        leftValue = 1 - xDist[i][j];
        rightValue = 1 + xDist[i][j];
        upValue = 1 + yDist[i][j];
        downValue = 1 - yDist[i][j];
          
        //Move in each direction, 0 being up and continuing clockwise
        if (rand < upValue) {
          try {
            if (cells[i - 1][j] != 1) {
              cells[i][j] = 0;
              cells[i - 1][j] = 1;
            }
          }
          
          catch (IndexOutOfBoundsException e) {
          }
        }
          
        //Right
        else if (rand < (upValue + rightValue)) {
          try {
            if (cells[i][j + 1] != 1) {
              cells[i][j] = 0;
              cells[i][j + 1] = 1;
            }
          }
        
          catch (IndexOutOfBoundsException e) {
          }
        }
          
        //Down
        else if (rand < (upValue + rightValue + downValue)) {
          try {
            if (cells[i + 1][j] != 1) {
              cells[i][j] = 0;
              cells[i + 1][j] = 1;
            }
          }
          
          catch (IndexOutOfBoundsException e) {
          }
        }
          
        //Left
        else if (rand < 4) {
          try {
            if (cells[i][j - 1] != 1) {
              cells[i][j] = 0;
              cells[i][j - 1] = 1;
            }
          }
          
          catch (IndexOutOfBoundsException e) {
          }
        }
          
        //Otherwise they stay still and nothing changes
      }
    }
  }
}

void findDist() {
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      //This will give the distance of the last strike when compared to the size of the grid
      //This is for the "weighted random" system that takes these ratios and creates sqewed probablities to urge them into a certain direction
      xDist[i][j] = (i - lastStrikeX) / float(n);
      yDist[i][j] = (j - lastStrikeY) / float(n);
      
      //Subtract their values from one or negative one, depending on if they're positive or negative
      //The goal is to have a closer distance to the last lightning strike make them more urgent
      //Having a magnitude between 0 and 1 makes it very simple
      if (xDist[i][j] < 0)
        xDist[i][j] = -1 + xDist[i][j];
        
      else 
        xDist[i][j] = 1 - xDist[i][j];
        
      if (yDist[i][j] < 0)
        yDist[i][j] = -1 + yDist[i][j];
        
      else 
        yDist[i][j] = 1 - yDist[i][j];
    }
  }
}

void checkLightning() {
  if (genCount % frq == 0)
    createLightning();
  
  else if (genCount % frq == 1)
    deleteLightning();
  
}

void createLightning() {
  lightningX = int(random(n));
  lightningY = int(random(n));
  
    for (int i = (lightningX - r); i < (lightningX + r); i++) {
      for (int j = (lightningY - r); j < (lightningY + r); j++) {
        try {
          cells[i][j] = 2;
      }
      
      catch (IndexOutOfBoundsException e) {
      } 
    }
  }
}

void deleteLightning() {
  lastStrikeX = lightningX;
  lastStrikeY = lightningY;
  
    for (int i = (lightningX - r); i < (lightningX + r); i++) {
      for (int j = (lightningY - r); j < (lightningY + r); j++) {
        try {
          cells[i][j] = 0;
      }
      
      catch (IndexOutOfBoundsException e) {
      }
    }
  }
}

void moveTornado () {
  
}
